#pragma kernel CSMain

#define PI 3.14159265359

RWStructuredBuffer<float2> _Positions;
RWStructuredBuffer<float> _Rotations;
RWStructuredBuffer<float2> _Forces;
RWStructuredBuffer<float2> _Velocities;
RWStructuredBuffer<float> _NoiseAngle;

float _ForwardWeight, _SeparationWeight, _AlignmentWeight, _CohesionWeight, _ViewRadius, _ViewAngle, _NoiseWeight;
int _NoBoids;
bool _Noise;

struct Quaternion
{
    float x, y, z, w;
};

struct EulerAngle
{
    float x, y, z;
};

float CosineAngleBetweenTwoVectors(float2 v1, float2 v2)
{
    float a = v1.x * v2.x + v1.y * v2.y;
    float b = length(v1) * length(v2);
    
    return a/b;
}

float2 MakeVecAngl(float angle)
{
    return float2(-sin(radians(angle)), cos(radians(angle)));
}

float VecToAngle(float2 v)
{
    return degrees(atan2(-v.x, v.y));
}

float2 MakeVecAnglRel(float angle, float2 parentVector)
{
    float parentAngle = VecToAngle(parentVector);

    float absoluteAngle = parentAngle + angle;

    if (absoluteAngle < -180.f)
        absoluteAngle += 360.f;
    else if (absoluteAngle > 180.f)
        absoluteAngle -= 360.f;

    return MakeVecAngl(absoluteAngle);
}

float easeInQuart(float x)
{
    return x * x * x * x;
}
float easeInCubic(float x)
{
    return x * x * x;
}

void ComputeVectors(uint id)
{
    if (id < _NoBoids)
    {
        float2 force = float2(0.f, 0.f);
        float2 separation = float2(0.f, 0.f);
        float2 cohesion = float2(0.f, 0.f);
        float rotation = float2(0.f, 0.f);
        float2 rotationToForce;
        int interactions = 0;
        float2 smoothRelVec;
        float2 relativeVec;
        float rotationDiff;
        
        float2 avgDirectionVec = float2(0, 0);
        float2 directionVec;
        
        Quaternion avgQuaternion;
        
        if (_Velocities[id].x == 0 && _Velocities[id].y == 0)
        {
            _Rotations[id] = 0;
        }
        else
        {
            float2 normalizedVelocity = normalize(_Velocities[id]);
            
            rotation = atan2(normalizedVelocity.y, normalizedVelocity.x);
            _Rotations[id] = degrees(rotation) - 90.f;
        }
    
        directionVec = float2(-sin(radians(_Rotations[id])), cos(radians(_Rotations[id])));
        
        // +---------------------------------------------+
        /* | */force += _ForwardWeight * directionVec;// |
        // +---------------------------------------------+
        
        
        
        // +--------------------------------------------------------------------------------------+
        /* | */force += _NoiseWeight * MakeVecAnglRel(_NoiseAngle[id], directionVec) * _Noise; // |
        // +--------------------------------------------------------------------------------------+
        
        for (int i = 0; i < _NoBoids; i++)
        {
            if(id != i)
            {
                relativeVec = _Positions[id] - _Positions[i];
                if (length(relativeVec) < _ViewRadius && CosineAngleBetweenTwoVectors(directionVec, -relativeVec) > _ViewAngle)
                {
                    interactions++;
                    
                    //distance in percentage compared to _ViewRadius
                    float distP = (_ViewRadius - length(relativeVec)) / _ViewRadius;
                    separation += relativeVec / length(relativeVec) * _ViewRadius * easeInCubic(distP);
                    
                    cohesion += _Positions[i];
                    
                    avgDirectionVec += normalize(_Velocities[i]);
                }
            }
        }
        
        
        if(interactions != 0)
        {
            separation /= interactions;
            cohesion /= interactions;
            avgDirectionVec /= interactions;
            
            // +-------------------------------------------------------------+
            /* | */force += (cohesion - _Positions[id]) * _CohesionWeight;// |
            // +-------------------------------------------------------------+
            // What does this do? ^^^^^^^^^^^^^^^^^^^^
            
            float avgRotation;
            // if there is at least a boid around apply the alignment
            if (avgDirectionVec.x != 0 || avgDirectionVec.y != 0)
            {
                avgRotation = degrees(atan2(avgDirectionVec.y, avgDirectionVec.x)) - 90.f;
            // +---------------------------------------------------------------------------------------------------+
            /* | */ force += _AlignmentWeight * float2(-sin(radians(avgRotation)), cos(radians(avgRotation))); //  |
            // +---------------------------------------------------------------------------------------------------+
            }
        }
        
        // +----------------------------------------------+
        /* | */force += separation * _SeparationWeight;// |
        // +----------------------------------------------+
        
        if(length(force) != 0)
        {
            force /= length(force);
        }
        else
        {
            force = float2(0, 0);
        }
        
        _Forces[id] = force;
    }
}

[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    ComputeVectors(id.x);
}
